import Markdoc from "@markdoc/markdoc";
import crypto from "node:crypto";
import fs from "node:fs";
import { fileURLToPath, pathToFileURL } from "node:url";
import {
  hasContentFlag,
  isValidUrl,
  MarkdocError,
  parseFrontmatter,
  prependForwardSlash,
  PROPAGATED_ASSET_FLAG
} from "./utils.js";
import { emitESMImage } from "astro/assets";
import { bold, red, yellow } from "kleur/colors";
import path from "node:path";
import { normalizePath } from "vite";
import { loadMarkdocConfig } from "./load-config.js";
import { setupConfig } from "./runtime.js";
const markdocTokenizer = new Markdoc.Tokenizer({
  // Strip <!-- comments --> from rendered output
  // Without this, they're rendered as strings!
  allowComments: true
});
function markdocIntegration(legacyConfig) {
  if (legacyConfig) {
    console.log(
      `${red(
        bold("[Markdoc]")
      )} Passing Markdoc config from your \`astro.config\` is no longer supported. Configuration should be exported from a \`markdoc.config.mjs\` file. See the configuration docs for more: https://docs.astro.build/en/guides/integrations-guide/markdoc/#configuration`
    );
    process.exit(0);
  }
  let markdocConfigResult;
  let markdocConfigResultId = "";
  return {
    name: "@astrojs/markdoc",
    hooks: {
      "astro:config:setup": async (params) => {
        const {
          config: astroConfig,
          updateConfig,
          addContentEntryType
        } = params;
        markdocConfigResult = await loadMarkdocConfig(astroConfig);
        if (markdocConfigResult) {
          markdocConfigResultId = normalizePath(fileURLToPath(markdocConfigResult.fileUrl));
        }
        const userMarkdocConfig = (markdocConfigResult == null ? void 0 : markdocConfigResult.config) ?? {};
        function getEntryInfo({ fileUrl, contents }) {
          const parsed = parseFrontmatter(contents, fileURLToPath(fileUrl));
          return {
            data: parsed.data,
            body: parsed.content,
            slug: parsed.data.slug,
            rawData: parsed.matter
          };
        }
        addContentEntryType({
          extensions: [".mdoc"],
          getEntryInfo,
          // Markdoc handles script / style propagation
          // for Astro components internally
          handlePropagation: false,
          async getRenderModule({ contents, fileUrl, viteId }) {
            const entry = getEntryInfo({ contents, fileUrl });
            const tokens = markdocTokenizer.tokenize(entry.body);
            const ast = Markdoc.parse(tokens);
            const pluginContext = this;
            const markdocConfig = await setupConfig(userMarkdocConfig);
            const filePath = fileURLToPath(fileUrl);
            const validationErrors = Markdoc.validate(
              ast,
              /* Raised generics issue with Markdoc core https://github.com/markdoc/markdoc/discussions/400 */
              markdocConfig
            ).filter((e) => {
              return (
                // Ignore `variable-undefined` errors.
                // Variables can be configured at runtime,
                // so we cannot validate them at build time.
                e.error.id !== "variable-undefined" && (e.error.level === "error" || e.error.level === "critical")
              );
            });
            if (validationErrors.length) {
              const frontmatterBlockOffset = entry.rawData.split("\n").length + 2;
              const rootRelativePath = path.relative(fileURLToPath(astroConfig.root), filePath);
              throw new MarkdocError({
                message: [
                  `**${String(rootRelativePath)}** contains invalid content:`,
                  ...validationErrors.map((e) => `- ${e.error.message}`)
                ].join("\n"),
                location: {
                  // Error overlay does not support multi-line or ranges.
                  // Just point to the first line.
                  line: frontmatterBlockOffset + validationErrors[0].lines[0],
                  file: viteId
                }
              });
            }
            if (astroConfig.experimental.assets) {
              await emitOptimizedImages(ast.children, {
                astroConfig,
                pluginContext,
                filePath
              });
            }
            const res = `import {
							createComponent,
							renderComponent,
						} from 'astro/runtime/server/index.js';
						import { Renderer } from '@astrojs/markdoc/components';
						import { collectHeadings, setupConfig, setupConfigSync, Markdoc } from '@astrojs/markdoc/runtime';
${markdocConfigResult ? `import _userConfig from ${JSON.stringify(
              markdocConfigResultId
            )};
const userConfig = _userConfig ?? {};` : "const userConfig = {};"}${astroConfig.experimental.assets ? `
import { experimentalAssetsConfig } from '@astrojs/markdoc/experimental-assets-config';
userConfig.nodes = { ...experimentalAssetsConfig.nodes, ...userConfig.nodes };` : ""}
const stringifiedAst = ${JSON.stringify(
              /* Double stringify to encode *as* stringified JSON */
              JSON.stringify(ast)
            )};
export function getHeadings() {
	${/* Yes, we are transforming twice (once from `getHeadings()` and again from <Content /> in case of variables).
            TODO: propose new `render()` API to allow Markdoc variable passing to `render()` itself,
            instead of the Content component. Would remove double-transform and unlock variable resolution in heading slugs. */
            ""}
	const headingConfig = userConfig.nodes?.heading;
	const config = setupConfigSync(headingConfig ? { nodes: { heading: headingConfig } } : {});
	const ast = Markdoc.Ast.fromJSON(stringifiedAst);
	const content = Markdoc.transform(ast, config);
	return collectHeadings(Array.isArray(content) ? content : content.children);
}

export const Content = createComponent({
	async factory(result, props) {
		const config = await setupConfig({
			...userConfig,
			variables: { ...userConfig.variables, ...props },
		});
		
		return renderComponent(
			result,
			Renderer.name,
			Renderer,
			{ stringifiedAst, config },
			{}
		);
	},
	propagation: 'self',
});`;
            return { code: res };
          },
          contentModuleTypes: await fs.promises.readFile(
            new URL("../template/content-module-types.d.ts", import.meta.url),
            "utf-8"
          )
        });
        let rollupOptions = {};
        if (markdocConfigResult) {
          rollupOptions = {
            output: {
              // Split Astro components from your `markdoc.config`
              // to only inject component styles and scripts at runtime.
              manualChunks(id, { getModuleInfo }) {
                var _a, _b;
                if (markdocConfigResult && hasContentFlag(id, PROPAGATED_ASSET_FLAG) && ((_b = (_a = getModuleInfo(id)) == null ? void 0 : _a.importers) == null ? void 0 : _b.includes(markdocConfigResultId))) {
                  return createNameHash(id, [id]);
                }
              }
            }
          };
        }
        updateConfig({
          vite: {
            vite: {
              ssr: {
                external: ["@astrojs/markdoc/prism", "@astrojs/markdoc/shiki"]
              }
            },
            build: {
              rollupOptions
            },
            plugins: [
              {
                name: "@astrojs/markdoc:astro-propagated-assets",
                enforce: "pre",
                // Astro component styles and scripts should only be injected
                // When a given Markdoc file actually uses that component.
                // Add the `astroPropagatedAssets` flag to inject only when rendered.
                resolveId(id, importer) {
                  if (importer === markdocConfigResultId && id.endsWith(".astro")) {
                    return this.resolve(id + "?astroPropagatedAssets", importer, {
                      skipSelf: true
                    });
                  }
                }
              }
            ]
          }
        });
      },
      "astro:server:setup": async ({ server }) => {
        server.watcher.on("all", (event, entry) => {
          if (prependForwardSlash(pathToFileURL(entry).pathname) === markdocConfigResultId) {
            console.log(
              yellow(
                `${bold("[Markdoc]")} Restart the dev server for config changes to take effect.`
              )
            );
          }
        });
      }
    }
  };
}
async function emitOptimizedImages(nodeChildren, ctx) {
  for (const node of nodeChildren) {
    if (node.type === "image" && typeof node.attributes.src === "string" && shouldOptimizeImage(node.attributes.src)) {
      const resolved = await ctx.pluginContext.resolve(node.attributes.src, ctx.filePath);
      if ((resolved == null ? void 0 : resolved.id) && fs.existsSync(new URL(prependForwardSlash(resolved.id), "file://"))) {
        const src = await emitESMImage(
          resolved.id,
          ctx.pluginContext.meta.watchMode,
          ctx.pluginContext.emitFile,
          { config: ctx.astroConfig }
        );
        node.attributes.__optimizedSrc = src;
      } else {
        throw new MarkdocError({
          message: `Could not resolve image ${JSON.stringify(
            node.attributes.src
          )} from ${JSON.stringify(ctx.filePath)}. Does the file exist?`
        });
      }
    }
    await emitOptimizedImages(node.children, ctx);
  }
}
function shouldOptimizeImage(src) {
  return !isValidUrl(src) && !src.startsWith("/");
}
function createNameHash(baseId, hashIds) {
  const baseName = baseId ? path.parse(baseId).name : "index";
  const hash = crypto.createHash("sha256");
  for (const id of hashIds) {
    hash.update(id, "utf-8");
  }
  const h = hash.digest("hex").slice(0, 8);
  const proposedName = baseName + "." + h;
  return proposedName;
}
export {
  markdocIntegration as default
};
